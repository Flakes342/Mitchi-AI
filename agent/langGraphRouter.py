import urllib.parse
from langchain_core.runnables import RunnableLambda
from langgraph.graph import StateGraph, END
from agent.chromaMemory import handle_user_input 
from typing import TypedDict, Dict, Any, List
from agent.llm import get_intent, get_plan
from agent.tools.clock import clock
from agent.tools.search import search_web
from agent.tools.app_launcher import open_app
from agent.tools.recommend import recommend_music
from agent.tools.shell_command import linux_commands
from agent.tools.system_control import system_control
from agent.tools.scraper import scraper_tool  # NEW
from agent.gmail_tool.gmail_service import email_manager  # NEW
import logging

logger = logging.getLogger(__name__)

# --- BitBud state
class BitBudState(TypedDict, total=False):
    input: str
    output: str
    function: str
    args: Dict[str, Any]
    tool_chain: List[Dict[str, Any]]
    current_tool_index: int
    execution_results: List[str]
    clarify: str # --- NEW
    reasoning: str # --- NEW
    steps: List[str] # --- NEW
    final_instruction: str # --- NEW


def fallback(args: Dict[str, Any] = None) -> str:
    """Fallback function that uses RAG for unknown intents."""
    # Remove the problematic global user_input reference
    user_input = args.get("user_input", "") if args else ""
    logger.info(f"user_input_fallback: {user_input}")
    
    if user_input:
        return handle_user_input(user_input)
    return "I'm not sure how to help with that."


FUNCTION_HANDLERS = {
    "open_app": open_app,
    "recommend_music": recommend_music,
    "search_web": search_web,
    "linux_commands": linux_commands,
    "clock": clock,
    "system_control": system_control,
    "scraper_tool": scraper_tool,  # NEW
    "email_manager": email_manager,  # NEW
    "fallback": fallback
}


def parse_args(args):
    if isinstance(args, dict):
        return args
    if isinstance(args, str):
        return dict(urllib.parse.parse_qsl(args))
    return {}


def normalize_intent_result(result: Any) -> List[Dict[str, Any]]:
    """Normalizing LLM intent result to consistent format >> dict in this case."""
    if isinstance(result, list):
        return result
    if isinstance(result, dict):
        return [result]
    return []

# --- CoT Planner  # --- NEW
def create_plan(state: BitBudState) -> Dict[str, Any]:
    user_input = state["input"]
    
    logger.info(f"Creating plan for user input: {user_input}")

    plan_result = get_plan(user_input)

    if not plan_result:
        logger.warning("No plan generated by LLM, falling back to RAG.")
        return {
            "clarify": None,
            "reasoning": "No plan generated",
            "steps": [],
            "final_instruction": {user_input}
        }
    logger.info(f"Plan generated: {plan_result}")

    return plan_result

# --- Route input to functions or fallback to RAG
def route_input(state):
    user_input = state["input"] 
    plan_result = create_plan(state) 
    clarify = plan_result.get("clarify", None) 
    reasoning = plan_result.get("reasoning", "") 
    steps = plan_result.get("steps", []) 
    final_instruction = plan_result.get("final_instruction", user_input) 

    result = get_intent(user_input, clarify, reasoning, steps, final_instruction) 

    tool_chain = normalize_intent_result(result)
    
    if not tool_chain:
        # Fallback to RAG - create fallback tool chain
        tool_chain = [{
            "function": "fallback",
            "args": {"user_input": user_input}
        }]

    logger.warning(f"Intent returned by LLM: {result}")
    logger.warning(f"Tool Chain by LLM: {tool_chain}")

    first_tool = tool_chain[0]
    func = first_tool.get("function")
    args = parse_args(first_tool.get("args", {}))

    if func == "fallback" and "user_input" not in args: # Fallback function doesn't give any args via LLM
        args["user_input"] = user_input
        tool_chain[0]["args"] = args # Tool Chain Updated

    return {
        "function": func,
        "args": args,
        "output": "",
        "tool_chain": tool_chain,
        "current_tool_index": 0,
        "execution_results": [],
        "clarify": clarify,
        "reasoning": reasoning,
        "steps": steps,
        "final_instruction": final_instruction
    }


def execute_single_tool(state: BitBudState) -> Dict[str, Any]:
    """Execute a single tool and return the result."""
    func = state.get("function")
    args = state.get("args", {})
    execution_results = state.get("execution_results", []) 
    
    if func not in FUNCTION_HANDLERS:
        error_msg = f"Unknown function: {func}"
        execution_results.append(error_msg)
        return {
            "output": error_msg,
            "execution_results": execution_results
        }
    
    try:
        handler = FUNCTION_HANDLERS[func]
        
        # Function-specific handling >> handler functions have different signatures
        if func == "open_app":
            name = args.get("name", "")
            query = args.get("query", "")
            result = handler(name, query)
        elif func == "search_web":
            result = handler(args.get("query", ""))
        elif func == "linux_commands":
            result = handler(args.get("command", ""))
        elif func == "recommend_music":
            result = handler()
        elif func in ["clock", "system_control", "fallback"]:
            result = handler(args)
        elif func == "scraper_tool":
            result = handler(args)
        elif func == "email_manager":
            result = handler(args)
        # Default case for other tools
        else:
            result = handler(args)
        
        output = str(result)
        execution_results.append(output)  # Adding tool result to execution_results
        
        logger.info(f"Executed {func} with args {args}, result: {result}")
        return {
            "output": output,
            "execution_results": execution_results
        }
        
    except Exception as e:
        error_msg = f"Error executing {func}: {str(e)}"
        execution_results.append(error_msg)  # Adding error to execution_results
        logger.error(error_msg)
        return {
            "output": error_msg,
            "execution_results": execution_results
        }

def process_tool_chain(state: BitBudState) -> Dict[str, Any]:
    """Process the next tool in the chain."""
    tool_chain = state.get("tool_chain", [])
    current_index = state.get("current_tool_index", 0)
    execution_results = state.get("execution_results", [])
    
    logger.info(f"Processing tool chain: index {current_index}/{len(tool_chain)}")
    
    # Get current tool to execute
    current_tool = tool_chain[current_index]
    func = current_tool.get("function")
    args = parse_args(current_tool.get("args", {}))
    
    logger.info(f"Executing tool {current_index + 1}/{len(tool_chain)}: {func} with args {args}")
    
    temp_state = {
        "function": func,
        "args": args,
        "execution_results": execution_results
    }
    
    # Execute the current tool
    result = execute_single_tool(temp_state)
    output = result.get("output", "")
    updated_execution_results = result.get("execution_results", execution_results)
    
    logger.info(f"Tool {func} executed. Output: {output}")
    
    # Return updated state
    return {
        "function": func,
        "args": args,
        "current_tool_index": current_index + 1,
        "execution_results": updated_execution_results,
        "output": output,
        "tool_chain": tool_chain
    }

def finalize_tool_chain(state: BitBudState) -> Dict[str, Any]:
    """Finalize the tool chain execution and combine all results."""
    execution_results = state.get("execution_results", [])
    
    logger.info(f'Execution Results: {execution_results}')
    final_output = "\n".join(execution_results) if execution_results else "All tasks completed."
    logger.info(f"Tool chain completed. Final output: {final_output}")
    
    return {
        "output": final_output,
        "function": "completed",
        "execution_results": execution_results
    }

def should_continue_chain(state: BitBudState) -> str:
    """Determine if there are more tools to execute in the chain."""
    tool_chain = state.get("tool_chain", [])
    current_index = state.get("current_tool_index", 0)
    
    logger.info(f"Checking chain continuation: {current_index} < {len(tool_chain)}")
    
    if current_index < len(tool_chain):
        return "continue_chain"
    return "finalize_chain"


def decide_execution_path(state: BitBudState) -> str:
    """Decide whether to use single tool execution or tool chain processing."""
    tool_chain = state.get("tool_chain", [])
    func = state.get("function")
    
    logger.info(f"Deciding execution path: tool_chain length = {len(tool_chain)}")
    
    if len(tool_chain) > 1:
        return "process_tool_chain"
    
    # Single tool execution
    if func in FUNCTION_HANDLERS:
        return "execute_single_tool"
    
    return "execute_single_tool"


def build_graph():
    try:
        logger.info("Starting to build BitBud graph...")

        graph = StateGraph(BitBudState)

        # nodes - Added create_plan node
        graph.add_node("create_plan", RunnableLambda(create_plan))
        graph.add_node("route_input", RunnableLambda(route_input))
        graph.add_node("execute_single_tool", RunnableLambda(execute_single_tool))
        graph.add_node("process_tool_chain", RunnableLambda(process_tool_chain))
        graph.add_node("finalize_tool_chain", RunnableLambda(finalize_tool_chain))

        # entry point - now starts with planning
        graph.set_entry_point("create_plan")
        
        # Flow: Plan -> Route -> Execute
        graph.add_edge("create_plan", "route_input")

        # entry point and conditional edges
        # graph.set_entry_point("route_input")
        graph.add_conditional_edges("route_input", decide_execution_path, {
            "execute_single_tool": "execute_single_tool",
            "process_tool_chain": "process_tool_chain"
        })

        graph.add_conditional_edges("process_tool_chain", should_continue_chain, {
            "continue_chain": "process_tool_chain",
            "finalize_chain": "finalize_tool_chain"
        })

        graph.add_edge("execute_single_tool", END)
        graph.add_edge("finalize_tool_chain", END)

        logger.info("BitBud graph built successfully.")
        return graph.compile()

    except Exception as e:
        logger.exception("Failed to build BitBud graph due to:")
        raise e